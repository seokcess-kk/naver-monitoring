[Ticket 1] Secret 절대 비노출로 변경 (가장 먼저)
1-1. server/routes.ts 수정

대상:

GET /api/api-keys 응답

현재 문제:

storage.getApiKeyByUserId() 결과를 그대로 res.json() 해서 clientSecret이 브라우저로 내려갈 수 있음.

변경 지시:

응답을 아래 형태로 바꾸기

clientId는 내려줘도 되지만(노출 리스크 낮음),

clientSecret은 절대 내려주지 않기

대신 hasClientSecret: true/false만 제공

권장 응답 스펙 예시(개념):

{ clientId: "...", hasClientSecret: true, updatedAt: ... }

또는 키가 없으면 null

추가로 같이 수정 권장:

POST/PUT /api/api-keys 응답도 저장된 전체 레코드 대신, 위와 같은 “마스킹 응답”만 반환.

1-2. client/src/pages/dashboard.tsx 수정

대상:

useQuery로 받아오는 ApiKey | null 타입

변경 지시:

서버 응답 스펙이 바뀌므로, 프론트 타입도 바꿔야 합니다.

ApiKey(DB 모델) 그대로 쓰지 말고, API 응답 전용 타입을 새로 정의

예:

type ApiKeyPublic = { clientId: string; hasClientSecret: boolean; updatedAt?: string } | null

프론트 로직 변경:

지금은 if (!apiKey) return; 같은 방식인데, 앞으로는

if (!apiKey?.hasClientSecret) return; 로 체크.

1-3. client/src/components/api-key-setup.tsx 수정

대상:

“기존 키가 있는지(existingApiKey)” 체크 로직

변경 지시:

기존에는 ApiKey 전체를 받았을 가능성이 있으니,

이제는 hasClientSecret만 보고 “POST vs PUT” 결정하면 됩니다.

[Ticket 2] 입력 검증을 서버에서 스키마로 고정 (운영 안정성)
2-1. server/routes.ts 수정

대상 엔드포인트:

GET /api/search

GET /api/search/channel

변경 지시:

현재는 keyword만 느슨하게 검사하고, page/sort는 캐스팅 기반입니다.

아래 항목을 Zod로 “한 번에 검증”하도록 변경하세요.

검증 규칙(권장):

keyword: string, trim, 1~40자

sort: "sim" | "date" 기본 "sim"

page: 1~100 (너무 큰 페이지 호출 방지)

channel: "blog" | "cafe" | "kin" | "news" (channel API에만)

결과:

이상값이 들어오면 400으로 빠르게 반환 → 크롤링/외부 API 비용 방지

[Ticket 3] 레이트 리밋 추가 (API 남용 방지)
3-1. server/index.ts 수정

변경 지시:

express-rate-limit을 전체 /api 또는 특정 엔드포인트에 적용

권장 정책(예시):

/api/search: 분당 30회

/api/search/channel: 분당 60회

/api/api-keys: 분당 20회

추가 지시:

로그인(isAuthenticated)이 이미 있으니,

“IP 기준” + 가능하면 “userId 기준”도 고려

최소 구현은 IP 기준으로도 충분히 효과 큼

[Ticket 4] 크롤링(Puppeteer) 동시성 제한 + 캐시 적용 (서버 다운 방지)

현재 server/crawler.ts는 요청마다 브라우저를 띄우고 닫는 구조라, 동시 요청이 생기면 서버가 힘들어집니다.
배포 환경에서 “체감 장애”로 이어지는 1순위가 여기입니다.

4-1. server/crawler.ts 수정: 동시성 제한

변경 지시(가장 간단한 방식):

p-limit(동시성 제한) 또는 내부 큐를 적용

동시성 1~2로 고정

작업 형태(개념):

const limit = pLimit(1);

export const crawlNaverSearch = (keyword) => limit(() => 실제크롤링함수(keyword));

4-2. server/crawler.ts 수정: TTL 캐시

변경 지시:

keyword 기준으로 30~120초 캐시

동일 키워드 반복 조회 시 Puppeteer를 다시 띄우지 않도록

권장:

lru-cache 사용 (메모리 캐시, TTL 지원)

[Ticket 5] 네이버 OpenAPI 호출 캐시 + 오류 표준화
5-1. server/naver-api.ts 수정: 캐시 적용

대상:

searchBlog/searchCafe/searchKin/searchNews 또는 searchAllChannels

변경 지시:

keyword + sort + page + channel을 키로 TTL 캐시(30~120초)

네이버 OpenAPI가 순간적으로 429/5xx를 줄 때도 캐시가 방패 역할을 합니다.

5-2. server/naver-api.ts 수정: 에러 표준화

변경 지시:

지금은 .catch(() => ({ total:0, items:[] }))로 조용히 삼키는 부분이 있는데,

운영에서는 “사용자에게는 안전한 메시지”, “서버 로그에는 원인”이 남아야 합니다.

권장 방식:

사용자 응답: { total:0, items:[], error: "RATE_LIMIT" } 같은 제한된 에러 코드(선택)

서버 로그: status code, endpoint, keyword, userId 등

[Ticket 6] DB에 저장되는 Secret “암호화” (클라이언트 제공형으로 갈 경우 필수)

현재 shared/schema.ts의 api_keys.client_secret는 평문 저장입니다.
내부툴이면 “DB 접근 통제”로도 운영이 가능하지만, 클라이언트 제공형(멀티 유저/유료)로 갈 거면 앱 레벨 암호화를 추천합니다.

6-1. 새 파일 추가: server/crypto.ts

변경 지시:

ENCRYPTION_KEY(환경변수)를 받아서

encrypt(text), decrypt(text) 함수 제공

6-2. server/storage.ts 수정

변경 지시:

createApiKey/updateApiKey에서 clientSecret 저장 전에 encrypt

getApiKeyByUserId에서 decrypt는 “서버 내부에서 네이버 API 호출 직전”에만 수행
(Ticket 1에서처럼, 어차피 secret은 응답으로 안 내려가므로 프론트에는 영향 없음)

6-3. 환경변수 추가

Replit Secrets에 ENCRYPTION_KEY 추가

[Ticket 7] 운영 관측: requestId/latency/log 마스킹
7-1. server/index.ts 수정

변경 지시:

모든 요청에 requestId를 부여

/api/search, /api/search/channel은 latency(ms) 로그 남기기

절대 로그에 clientSecret이 찍히지 않게 마스킹(헤더/바디 출력 금지)

최종 흐름도 (작업 후 기대 구조)

사용자는 로그인

API 키 저장(POST/PUT) → 서버 DB에 암호화 저장(선택)

대시보드는 GET /api/api-keys로 hasClientSecret만 확인

검색 실행 시

크롤링: 동시성 1~2 제한 + TTL 캐시

OpenAPI: TTL 캐시 + 에러 표준화

운영: 레이트리밋 + requestId 로그로 안정성 확보